<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Černá Madonna – Kubistická Kamera</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="handles"></div>
  <video id="video" autoplay playsinline muted></video>

  <button id="toggle" class="mode-mesh"></button>

  <div id="footer-logos">
    <a href="https://tvoje-url.cz" target="_blank"><img src="Logos.png" alt="Logo"></a>
    <a href="https://jh-portfolio.cz" target="_blank"><img src="JH.png" alt="JH"></a>
  </div>

  <script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const video = document.getElementById('video');
  const toggle = document.getElementById('toggle');
  const handlesContainer = document.getElementById('handles');

  let mode = 'mesh';
  let rotationY = 0, rotationX = 0;
  let isDragging = false;
  let lastX = 0, lastY = 0;
  let deforming = false;
  let deformIndex = -1;
  let videoReady = false;

  const basePoints = [];
  const numSides = 6;
  const radius = 150;
  for (let i = 0; i < numSides; i++) {
    const angle = (i / numSides) * Math.PI * 2;
    basePoints.push({x: Math.cos(angle) * radius, y: Math.sin(angle) * radius, z: Math.sin(angle) * 40});
  }

  const handleEls = [];
  for (let i = 0; i < numSides; i++) {
    const el = document.createElement('div');
    el.className = 'handle';
    el.dataset.index = i;
    el.innerHTML = '<div class="pulse"></div><div class="ring"></div>';
    handlesContainer.appendChild(el);
    handleEls.push(el);
  }

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  function project(p) {
    const cosY = Math.cos(rotationY), sinY = Math.sin(rotationY);
    const cosX = Math.cos(rotationX), sinX = Math.sin(rotationX);
    let x = p.x * cosY - p.z * sinY;
    let z = p.x * sinY + p.z * cosY;
    let y = p.y * cosX - z * sinX;
    z = p.y * sinX + z * cosX;
    const scale = 1 / (1 + z / 300);
    return { x: canvas.width / 2 + x * scale, y: canvas.height / 2 + y * scale };
  }

  function drawMesh() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const pts = basePoints.map(project);
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 3;
    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.fill();
    ctx.stroke();
    updateHandles();
  }

  function drawCameraMesh() {
    if (!videoReady) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const pts = basePoints.map(project);
    const cx = pts.reduce((a, p) => a + p.x, 0) / pts.length;
    const cy = pts.reduce((a, p) => a + p.y, 0) / pts.length;

    for (let i = 0; i < pts.length; i++) {
      const p1 = pts[i];
      const p2 = pts[(i + 1) % pts.length];
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.closePath();
      ctx.clip();
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
    updateHandles();
  }

  function updateHandles() {
    const pts = basePoints.map(project);
    for (let i = 0; i < handleEls.length; i++) {
      handleEls[i].style.transform = `translate(${pts[i].x}px, ${pts[i].y}px)`;
    }
  }

  toggle.onclick = async () => {
    if (mode === 'mesh') {
      mode = 'camera';
      toggle.classList.replace('mode-mesh', 'mode-camera');
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
        video.srcObject = stream;
        await video.play();
        videoReady = true;
      } catch (err) {
        alert("Kamera nedostupná: " + err.message);
        mode = 'mesh';
        toggle.classList.replace('mode-camera', 'mode-mesh');
      }
    } else {
      mode = 'mesh';
      toggle.classList.replace('mode-camera', 'mode-mesh');
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(t => t.stop());
        video.srcObject = null;
      }
      videoReady = false;
    }
  };

  canvas.addEventListener('pointerdown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
  canvas.addEventListener('pointermove', e => {
    if (isDragging) {
      rotationY += (e.clientX - lastX) * 0.01;
      rotationX += (e.clientY - lastY) * 0.01;
    }
    lastX = e.clientX;
    lastY = e.clientY;
  });
  canvas.addEventListener('pointerup', () => { isDragging = false; });

  function loop() {
    if (mode === 'mesh') drawMesh();
    else drawCameraMesh();
    requestAnimationFrame(loop);
  }
  loop();
  </script>
</body>
</html>
